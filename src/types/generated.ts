/**
 * Generated by orval v6.30.2 üç∫
 * Do not edit manually.
 * Employ Me Api
 * OpenAPI spec version: 1.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  InfiniteData,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import axios from 'axios'
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
import type {
  ApplyToJobDto,
  JobDto,
  RegisterJobInputDto,
  RegisterUserInputDto,
  SignInDto,
  SignUpDto,
  SkillListOutputDto,
  TokenOutputDto,
  UpdateUserInputDto,
  UserWithTokensOutputDto
} from './generated.schemas'



/**
 * Login
 */
export const authControllerSignIn = (
    signInDto: SignInDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserWithTokensOutputDto>> => {
    
    return axios.post(
      `/auth/login`,
      signInDto,options
    );
  }



export const getAuthControllerSignInMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerSignIn>>, TError,{data: SignInDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerSignIn>>, TError,{data: SignInDto}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerSignIn>>, {data: SignInDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerSignIn(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerSignInMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerSignIn>>>
    export type AuthControllerSignInMutationBody = SignInDto
    export type AuthControllerSignInMutationError = AxiosError<void>

    export const useAuthControllerSignIn = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerSignIn>>, TError,{data: SignInDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof authControllerSignIn>>,
        TError,
        {data: SignInDto},
        TContext
      > => {

      const mutationOptions = getAuthControllerSignInMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Refresh tokens
 */
export const authControllerRefreshToken = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TokenOutputDto>> => {
    
    return axios.get(
      `/auth/refresh`,options
    );
  }


export const getAuthControllerRefreshTokenQueryKey = () => {
    return [`/auth/refresh`] as const;
    }

    
export const getAuthControllerRefreshTokenInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof authControllerRefreshToken>>>, TError = AxiosError<void>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerRefreshToken>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerRefreshTokenQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerRefreshToken>>> = ({ signal }) => authControllerRefreshToken({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerRefreshToken>>, TError, TData> & { queryKey: QueryKey }
}

export type AuthControllerRefreshTokenInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerRefreshToken>>>
export type AuthControllerRefreshTokenInfiniteQueryError = AxiosError<void>

export const useAuthControllerRefreshTokenInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof authControllerRefreshToken>>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerRefreshToken>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getAuthControllerRefreshTokenInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getAuthControllerRefreshTokenQueryOptions = <TData = Awaited<ReturnType<typeof authControllerRefreshToken>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerRefreshToken>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerRefreshTokenQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerRefreshToken>>> = ({ signal }) => authControllerRefreshToken({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authControllerRefreshToken>>, TError, TData> & { queryKey: QueryKey }
}

export type AuthControllerRefreshTokenQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerRefreshToken>>>
export type AuthControllerRefreshTokenQueryError = AxiosError<void>

export const useAuthControllerRefreshToken = <TData = Awaited<ReturnType<typeof authControllerRefreshToken>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerRefreshToken>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getAuthControllerRefreshTokenQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Sign Up
 */
export const authControllerSignUp = (
    signUpDto: SignUpDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserWithTokensOutputDto>> => {
    
    return axios.post(
      `/auth/signup`,
      signUpDto,options
    );
  }



export const getAuthControllerSignUpMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerSignUp>>, TError,{data: SignUpDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerSignUp>>, TError,{data: SignUpDto}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerSignUp>>, {data: SignUpDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerSignUp(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerSignUpMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerSignUp>>>
    export type AuthControllerSignUpMutationBody = SignUpDto
    export type AuthControllerSignUpMutationError = AxiosError<void>

    export const useAuthControllerSignUp = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerSignUp>>, TError,{data: SignUpDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof authControllerSignUp>>,
        TError,
        {data: SignUpDto},
        TContext
      > => {

      const mutationOptions = getAuthControllerSignUpMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Register a new user
 */
export const userControllerCreate = (
    registerUserInputDto: RegisterUserInputDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserWithTokensOutputDto>> => {
    
    return axios.post(
      `/user`,
      registerUserInputDto,options
    );
  }



export const getUserControllerCreateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerCreate>>, TError,{data: RegisterUserInputDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userControllerCreate>>, TError,{data: RegisterUserInputDto}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerCreate>>, {data: RegisterUserInputDto}> = (props) => {
          const {data} = props ?? {};

          return  userControllerCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerCreate>>>
    export type UserControllerCreateMutationBody = RegisterUserInputDto
    export type UserControllerCreateMutationError = AxiosError<unknown>

    export const useUserControllerCreate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerCreate>>, TError,{data: RegisterUserInputDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof userControllerCreate>>,
        TError,
        {data: RegisterUserInputDto},
        TContext
      > => {

      const mutationOptions = getUserControllerCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Update a user
 */
export const userControllerUpdate = (
    id: string,
    updateUserInputDto: UpdateUserInputDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserWithTokensOutputDto>> => {
    
    return axios.patch(
      `/user/${id}`,
      updateUserInputDto,options
    );
  }



export const getUserControllerUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdate>>, TError,{id: string;data: UpdateUserInputDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdate>>, TError,{id: string;data: UpdateUserInputDto}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerUpdate>>, {id: string;data: UpdateUserInputDto}> = (props) => {
          const {id,data} = props ?? {};

          return  userControllerUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerUpdate>>>
    export type UserControllerUpdateMutationBody = UpdateUserInputDto
    export type UserControllerUpdateMutationError = AxiosError<unknown>

    export const useUserControllerUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdate>>, TError,{id: string;data: UpdateUserInputDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof userControllerUpdate>>,
        TError,
        {id: string;data: UpdateUserInputDto},
        TContext
      > => {

      const mutationOptions = getUserControllerUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Upload user resume
 */
export const userControllerUploadResume = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserWithTokensOutputDto>> => {
    
    return axios.post(
      `/user/${id}/resume`,undefined,options
    );
  }



export const getUserControllerUploadResumeMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerUploadResume>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userControllerUploadResume>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerUploadResume>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  userControllerUploadResume(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerUploadResumeMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerUploadResume>>>
    
    export type UserControllerUploadResumeMutationError = AxiosError<unknown>

    export const useUserControllerUploadResume = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerUploadResume>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof userControllerUploadResume>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getUserControllerUploadResumeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const jobControllerList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<JobDto[]>> => {
    
    return axios.get(
      `/job/list`,options
    );
  }


export const getJobControllerListQueryKey = () => {
    return [`/job/list`] as const;
    }

    
export const getJobControllerListInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof jobControllerList>>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof jobControllerList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getJobControllerListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof jobControllerList>>> = ({ signal }) => jobControllerList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof jobControllerList>>, TError, TData> & { queryKey: QueryKey }
}

export type JobControllerListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof jobControllerList>>>
export type JobControllerListInfiniteQueryError = AxiosError<unknown>

export const useJobControllerListInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof jobControllerList>>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof jobControllerList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getJobControllerListInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getJobControllerListQueryOptions = <TData = Awaited<ReturnType<typeof jobControllerList>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jobControllerList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getJobControllerListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof jobControllerList>>> = ({ signal }) => jobControllerList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof jobControllerList>>, TError, TData> & { queryKey: QueryKey }
}

export type JobControllerListQueryResult = NonNullable<Awaited<ReturnType<typeof jobControllerList>>>
export type JobControllerListQueryError = AxiosError<unknown>

export const useJobControllerList = <TData = Awaited<ReturnType<typeof jobControllerList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jobControllerList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getJobControllerListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const jobControllerCreate = (
    registerJobInputDto: RegisterJobInputDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<JobDto>> => {
    
    return axios.post(
      `/job/create`,
      registerJobInputDto,options
    );
  }



export const getJobControllerCreateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof jobControllerCreate>>, TError,{data: RegisterJobInputDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof jobControllerCreate>>, TError,{data: RegisterJobInputDto}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof jobControllerCreate>>, {data: RegisterJobInputDto}> = (props) => {
          const {data} = props ?? {};

          return  jobControllerCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type JobControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof jobControllerCreate>>>
    export type JobControllerCreateMutationBody = RegisterJobInputDto
    export type JobControllerCreateMutationError = AxiosError<unknown>

    export const useJobControllerCreate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof jobControllerCreate>>, TError,{data: RegisterJobInputDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof jobControllerCreate>>,
        TError,
        {data: RegisterJobInputDto},
        TContext
      > => {

      const mutationOptions = getJobControllerCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const jobControllerGetOne = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<JobDto>> => {
    
    return axios.get(
      `/job/${id}`,options
    );
  }


export const getJobControllerGetOneQueryKey = (id: string,) => {
    return [`/job/${id}`] as const;
    }

    
export const getJobControllerGetOneInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof jobControllerGetOne>>>, TError = AxiosError<unknown>>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof jobControllerGetOne>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getJobControllerGetOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof jobControllerGetOne>>> = ({ signal }) => jobControllerGetOne(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof jobControllerGetOne>>, TError, TData> & { queryKey: QueryKey }
}

export type JobControllerGetOneInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof jobControllerGetOne>>>
export type JobControllerGetOneInfiniteQueryError = AxiosError<unknown>

export const useJobControllerGetOneInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof jobControllerGetOne>>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof jobControllerGetOne>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getJobControllerGetOneInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getJobControllerGetOneQueryOptions = <TData = Awaited<ReturnType<typeof jobControllerGetOne>>, TError = AxiosError<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jobControllerGetOne>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getJobControllerGetOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof jobControllerGetOne>>> = ({ signal }) => jobControllerGetOne(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof jobControllerGetOne>>, TError, TData> & { queryKey: QueryKey }
}

export type JobControllerGetOneQueryResult = NonNullable<Awaited<ReturnType<typeof jobControllerGetOne>>>
export type JobControllerGetOneQueryError = AxiosError<unknown>

export const useJobControllerGetOne = <TData = Awaited<ReturnType<typeof jobControllerGetOne>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jobControllerGetOne>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getJobControllerGetOneQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const jobControllerApply = (
    id: string,
    applyToJobDto: ApplyToJobDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<JobDto>> => {
    
    return axios.post(
      `/job/${id}/apply`,
      applyToJobDto,options
    );
  }



export const getJobControllerApplyMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof jobControllerApply>>, TError,{id: string;data: ApplyToJobDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof jobControllerApply>>, TError,{id: string;data: ApplyToJobDto}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof jobControllerApply>>, {id: string;data: ApplyToJobDto}> = (props) => {
          const {id,data} = props ?? {};

          return  jobControllerApply(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type JobControllerApplyMutationResult = NonNullable<Awaited<ReturnType<typeof jobControllerApply>>>
    export type JobControllerApplyMutationBody = ApplyToJobDto
    export type JobControllerApplyMutationError = AxiosError<unknown>

    export const useJobControllerApply = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof jobControllerApply>>, TError,{id: string;data: ApplyToJobDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof jobControllerApply>>,
        TError,
        {id: string;data: ApplyToJobDto},
        TContext
      > => {

      const mutationOptions = getJobControllerApplyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const skillControllerList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SkillListOutputDto>> => {
    
    return axios.get(
      `/skillList`,options
    );
  }


export const getSkillControllerListQueryKey = () => {
    return [`/skillList`] as const;
    }

    
export const getSkillControllerListInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof skillControllerList>>>, TError = AxiosError<SkillListOutputDto>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof skillControllerList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSkillControllerListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof skillControllerList>>> = ({ signal }) => skillControllerList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof skillControllerList>>, TError, TData> & { queryKey: QueryKey }
}

export type SkillControllerListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof skillControllerList>>>
export type SkillControllerListInfiniteQueryError = AxiosError<SkillListOutputDto>

export const useSkillControllerListInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof skillControllerList>>>, TError = AxiosError<SkillListOutputDto>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof skillControllerList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSkillControllerListInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getSkillControllerListQueryOptions = <TData = Awaited<ReturnType<typeof skillControllerList>>, TError = AxiosError<SkillListOutputDto>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof skillControllerList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSkillControllerListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof skillControllerList>>> = ({ signal }) => skillControllerList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 10000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof skillControllerList>>, TError, TData> & { queryKey: QueryKey }
}

export type SkillControllerListQueryResult = NonNullable<Awaited<ReturnType<typeof skillControllerList>>>
export type SkillControllerListQueryError = AxiosError<SkillListOutputDto>

export const useSkillControllerList = <TData = Awaited<ReturnType<typeof skillControllerList>>, TError = AxiosError<SkillListOutputDto>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof skillControllerList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSkillControllerListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




